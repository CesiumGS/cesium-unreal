// Copyright 2020-2021 CesiumGS, Inc. and Contributors

/*=============================================================================
	CesiumPointAttenuationVertexFactory.usf: point attenuation vertex factory shader code.
=============================================================================*/

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/VertexFactoryCommon.ush"

StructuredBuffer<float3> PositionBuffer;
float4 AttenuationParameters;
float4 ConstantColor;

#if USE_INSTANCING
	// Instanced stereo sets the eye index explicitly for instanced geometry
	#if INSTANCED_STEREO
	uint InstancedEyeIndex;
	#endif
#endif

/*
 * Per-vertex input. No vertex buffers are bound.
 */
struct FVertexFactoryInput
{
		uint  VertexId    : SV_VertexID;
		uint  InstanceId  : SV_InstanceID;
};

/** 
 * Per-vertex inputs. Used by passes with a trimmed down position-only shader.
 */
struct FPositionOnlyVertexFactoryInput
{
	uint    VertexId    : SV_VertexID;
};

/** 
 * Per-vertex inputs. Used by passes with a trimmed down position-and-normal-only shader.
 */
struct FPositionAndNormalOnlyVertexFactoryInput
{
	uint    VertexId	: SV_VertexID;
};

struct FVertexFactoryInterpolantsVSToPS
{
		TANGENTTOWORLD_INTERPOLATOR_BLOCK
		half4	Color : COLOR0;
		float2	TexCoords : TEXCOORD0;

#if INSTANCED_STEREO
		nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
#endif
};

/** Cached intermediates that would otherwise have to be computed multiple times. */
struct FVertexFactoryIntermediates
{
		float3 Position;
		float3 WorldPosition;
		float3 AttenuatedWorldPosition;

  	half3x3 TangentToLocal;
		half3x3 TangentToWorld;
		half TangentToWorldSign;
		half4 Color;
};

float3 ApplyAttenuation(float3 Position, float2 Offset) {
  Offset *= 100;
	return float3(Position.x + Offset.x, Position.y, Position.z + + Offset.y);

	/*float4 PositionClip = mul(View.WorldToClip, float4(Position,1));
	float2 PixelOffset = 10 * Offset;
	float2 ScreenOffset = PixelOffset; // Multiply by view dimensions?
	PositionClip.xy += positionClip.w * screenOffset;

	return mul(View.ClipToWorld, PositionClip).xyz;*/
}

half3x3 GetTangentToLocal(float3 Normal) {
		half3 N = abs(Normal);
		half3 Tangent = half3(1, 0, 0);

		// Find best basis vectors.
		if (N.z > N.x && N.z > N.y)
		{
			Tangent = half3(1, 0, 0);
		}
		else
		{
			Tangent = half3(0, 0, 1);
		}

		Tangent = (Tangent - Normal * dot(Tangent, Normal));
		Tangent = Tangent * rsqrt(dot(Tangent, Tangent));
		
		return half3x3(Tangent, cross(Tangent, Normal), Normal);
}

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
	FVertexFactoryIntermediates Intermediates = (FVertexFactoryIntermediates)0;
	half3x3 LocalToWorld = GetLocalToWorld3x3();

	uint PointIndex = Input.VertexId / 4;
	uint CornerIndex = Input.VertexId - PointIndex * 4;

	float3 Position = PositionBuffer[PointIndex];

	// Unreal uses counter-clockwise winding order.
	// 0 -- 2
	// |  / |
	// 1 ---3

	// Results in -0.5 for 0, 1 and 0.5 for 2, 3
	float OffsetX = CornerIndex / 2 - 0.5;
	// Results in 0.5 for 0, 2 and -0.5 for 1, 3
	float OffsetY = 0.5 - CornerIndex % 2 ;

	Intermediates.Position = Position;
	Intermediates.WorldPosition = TransformLocalToWorld(Position).xyz;
	Intermediates.AttenuatedWorldPosition = ApplyAttenuation(Intermediates.WorldPosition, float2(OffsetX, OffsetY));

	half3x3 TangentToLocal = half3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);//CalcTangentToLocal(Input.MetaData);
	Intermediates.TangentToLocal = TangentToLocal;
	Intermediates.TangentToWorldSign = Primitive.InvNonUniformScaleAndDeterminantSign.w;
	Intermediates.TangentToWorld = mul(TangentToLocal, LocalToWorld);

	return Intermediates;
}

/** Converts from vertex factory specific input to a FMaterialVertexParameters, which is used by vertex shader material inputs. */
FMaterialVertexParameters GetMaterialVertexParameters(
		FVertexFactoryInput Input,
		FVertexFactoryIntermediates Intermediates,
		float3 WorldPosition,
		half3x3 TangentToLocal)
{
		FMaterialVertexParameters Result = (FMaterialVertexParameters)0;
    
	Result.WorldPosition = WorldPosition;
	Result.TangentToWorld = Intermediates.TangentToWorld;
	Result.PreSkinnedNormal = TangentToLocal[2];
	Result.PreSkinnedPosition = WorldPosition;
	Result.VertexColor = float4(1, 0, 0, 1);//Intermediates.Color;

/*#if NUM_MATERIAL_TEXCOORDS_VERTEX
	Result.TexCoords[0] = PrecomputedUV_Quad[Input.VertexId % 4];
	#if NUM_MATERIAL_TEXCOORDS_VERTEX > 1
		Result.TexCoords[1] = Intermediates.Scale;
	#endif
#endif*/

    return Result;
}

float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return float4(Intermediates.AttenuatedWorldPosition, 1);//TransformLocalToTranslatedWorld(Intermediates.Position);
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input)
{
	return float3(0, 0, 1);//RotateLocalToWorld(bUseStaticBuffers ? Input.Normal.xyz : GetInstanceData(Input.VertexId).TangentToLocal[2], 0);
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return float3(0, 0, 1);//return Intermediates.TangentToWorld[2];
}


float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	float4x4 PreviousLocalToWorldTranslated = GetPrimitiveData(0).PreviousLocalToWorld;
    PreviousLocalToWorldTranslated[3][0] += ResolvedView.PrevPreViewTranslation.x;
    PreviousLocalToWorldTranslated[3][1] += ResolvedView.PrevPreViewTranslation.y;
    PreviousLocalToWorldTranslated[3][2] += ResolvedView.PrevPreViewTranslation.z;
    return mul(float4(Intermediates.Position, 1), PreviousLocalToWorldTranslated);
}

float4 VertexFactoryGetRasterizedWorldPosition(
		FVertexFactoryInput Input,
		FVertexFactoryIntermediates Intermediates,
		float4 InWorldPosition)
{
		return InWorldPosition;
}

float3 VertexFactoryGetPositionForVertexLighting(
		FVertexFactoryInput Input,
		FVertexFactoryIntermediates Intermediates,
		float3 TranslatedWorldPosition)
{
		return TranslatedWorldPosition;
}


/** Get the 3x3 tangent basis vectors for this vertex factory. This vertex factory will calculate the binormal on-the-fly. */
half3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return Intermediates.TangentToLocal;
}

#if INSTANCED_STEREO
uint VertexFactoryGetEyeIndex(uint InstanceId)
{
	#if USE_INSTANCING
		return InstancedEyeIndex;
	#else
		return InstanceId & 1;
	#endif
}
#endif

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(
		FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
	FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS)0;
	Interpolants.TangentToWorld0 = float4(Intermediates.TangentToWorld[0], 0);
	Interpolants.TangentToWorld2 = float4(Intermediates.TangentToWorld[2], Intermediates.TangentToWorldSign);
	Interpolants.Color = float4(1, 0, 0, 1);
	//Interpolants.TexCoords

#if INSTANCED_STEREO
	Interpolants.EyeIndex = 0;
#endif

	return Interpolants;
}

FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
    FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();

    Result.Particle.Color = half4(1, 1, 1, 1);
    Result.TwoSidedSign = 1;
		Result.VertexColor = Interpolants.Color;
		//Result.VertexColor.a = lerp(1, 1 - distance(Interpolants.TexCoords, 0.5), Interpolants.Color.a);

    half3 TangentToWorld0 = Interpolants.TangentToWorld0.xyz;
    half4 TangentToWorld2 = Interpolants.TangentToWorld2;
    Result.UnMirrored = TangentToWorld2.w;
    Result.TangentToWorld = AssembleTangentToWorld(TangentToWorld0, TangentToWorld2);

/*#if NUM_TEX_COORD_INTERPOLATORS
    Result.TexCoords[0] = Interpolants.TexCoords;
#endif*/

    return Result;
}

uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return 0;
}
