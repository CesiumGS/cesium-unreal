// Copyright 2020-2021 CesiumGS, Inc. and Contributors

/*=============================================================================
	CesiumPointAttenuationVertexFactory.usf: point attenuation vertex factory shader code.
=============================================================================*/

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/VertexFactoryCommon.ush"

StructuredBuffer<float3> PositionBuffer;
StructuredBuffer<float3> NormalBuffer;
Buffer<float4> ColorBuffer;

// Whether or not the point cloud has per-point colors.
uint bHasPointColors;
float3 AttenuationParameters;
float4 ConstantColor;

#if USE_INSTANCING
	// Instanced stereo sets the eye index explicitly for instanced geometry
	#if INSTANCED_STEREO
	uint InstancedEyeIndex;
	#endif
#endif

/*
 * Per-vertex input. No vertex buffers are bound.
 */
struct FVertexFactoryInput
{
		uint  VertexId    : SV_VertexID;
		uint  InstanceId  : SV_InstanceID;
};

/** 
 * Per-vertex inputs. Used by passes with a trimmed down position-only shader.
 */
struct FPositionOnlyVertexFactoryInput
{
	uint    VertexId    : SV_VertexID;
};

/** 
 * Per-vertex inputs. Used by passes with a trimmed down position-and-normal-only shader.
 */
struct FPositionAndNormalOnlyVertexFactoryInput
{
	uint    VertexId	: SV_VertexID;
};

struct FVertexFactoryInterpolantsVSToPS
{
		TANGENTTOWORLD_INTERPOLATOR_BLOCK
		half4	Color : COLOR0;
		float2	TexCoords : TEXCOORD0;

#if INSTANCED_STEREO
		nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
#endif
};

/** Cached intermediates that would otherwise have to be computed multiple times. */
struct FVertexFactoryIntermediates
{
		float3 Position;
		float3 AttenuatedWorldPosition;

  	half3x3 TangentToLocal;
		half3x3 TangentToWorld;
		half TangentToWorldSign;
		half4 Color;
};

float3 ApplyAttenuation(float4 WorldPosition, float2 Offset) {
	float4 PositionView = mul(WorldPosition, ResolvedView.TranslatedWorldToView);
	float4 PositionClip = mul(WorldPosition, ResolvedView.TranslatedWorldToClip);

	float MaximumPointSize = AttenuationParameters.x;
	float GeometricError = AttenuationParameters.y;
	float DepthMultiplier = AttenuationParameters.z;
	float Depth = PositionView.z / 100; // Get depth in meters
	float PointSize = min((GeometricError / Depth) * DepthMultiplier, MaximumPointSize);

	float2 PixelOffset = PointSize * Offset;
	float2 ScreenOffset = PixelOffset * ResolvedView.ViewSizeAndInvSize.zw;
	float2 ClipOffset = ScreenOffset * PositionClip.w;
	float4 ViewOffset = mul(float4(ClipOffset, PositionClip.z, 1), ResolvedView.ClipToView);
	ViewOffset /= ViewOffset.w;

	// Adjust x-component for the left-handed coordinate system.
	return WorldPosition.xyz + (-ViewOffset.x * ResolvedView.ViewRight + ViewOffset.y * ResolvedView.ViewUp);
}

half3x3 GetTangentToLocal(float3 Normal) {
		half3 N = abs(Normal);
		half3 Tangent = half3(1, 0, 0);

		// Find best basis vectors.
		if (N.z > N.x && N.z > N.y)
		{
			Tangent = half3(1, 0, 0);
		}
		else
		{
			Tangent = half3(0, 0, 1);
		}

		Tangent = (Tangent - Normal * dot(Tangent, Normal));
		Tangent = Tangent * rsqrt(dot(Tangent, Tangent));
		
		return half3x3(Tangent, cross(Tangent, Normal), Normal);
}

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
		FVertexFactoryIntermediates Intermediates = (FVertexFactoryIntermediates)0;
		half3x3 LocalToWorld = GetLocalToWorld3x3();

		uint PointIndex = Input.VertexId / 4;
		uint CornerIndex = Input.VertexId - (PointIndex * 4);

		float3 Position = PositionBuffer[PointIndex];

		// Unreal uses counter-clockwise winding order.
		// 0 --- 3
		// |  \  |
		// 1 --- 2

		// Results in -0.5 for 0, 1 and 0.5 for 2, 3
		float OffsetX = CornerIndex / 2 - 0.5;
		float OffsetY = -0.5f;
		if (CornerIndex == 0 || CornerIndex == 3) {
				OffsetY = 0.5;
		}

		Intermediates.Position = Position;

		float4 WorldPosition = TransformLocalToTranslatedWorld(Position);
		Intermediates.AttenuatedWorldPosition = ApplyAttenuation(WorldPosition, float2(OffsetX, OffsetY));

		half3x3 TangentToLocal = half3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);//CalcTangentToLocal(Input.MetaData);
		Intermediates.TangentToLocal = TangentToLocal;
		Intermediates.TangentToWorldSign = Primitive.InvNonUniformScaleAndDeterminantSign.w;
		Intermediates.TangentToWorld = mul(TangentToLocal, LocalToWorld);

		bool bHasColors = bHasPointColors;
		float4 Color = bHasColors ? ColorBuffer[PointIndex] : ConstantColor;
		Intermediates.Color = Color FMANUALFETCH_COLOR_COMPONENT_SWIZZLE;

		return Intermediates;
}

/** Converts from vertex factory specific input to a FMaterialVertexParameters, which is used by vertex shader material inputs. */
FMaterialVertexParameters GetMaterialVertexParameters(
		FVertexFactoryInput Input,
		FVertexFactoryIntermediates Intermediates,
		float3 WorldPosition,
		half3x3 TangentToLocal)
{
		FMaterialVertexParameters Result = (FMaterialVertexParameters)0;
    
		Result.WorldPosition = WorldPosition;
		Result.TangentToWorld = Intermediates.TangentToWorld;
		Result.PreSkinnedNormal = TangentToLocal[2];
		Result.PreSkinnedPosition = WorldPosition;
		Result.VertexColor = Intermediates.Color;

    return Result;
}

float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
		return float4(Intermediates.AttenuatedWorldPosition, 1);
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input)
{
		return float3(0, 0, 1);//RotateLocalToWorld(bUseStaticBuffers ? Input.Normal.xyz : GetInstanceData(Input.VertexId).TangentToLocal[2], 0);
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
		return float3(0, 0, 1);//return Intermediates.TangentToWorld[2];
}

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
		float4x4 PreviousLocalToWorldTranslated = GetPrimitiveData(0).PreviousLocalToWorld;
    PreviousLocalToWorldTranslated[3][0] += ResolvedView.PrevPreViewTranslation.x;
    PreviousLocalToWorldTranslated[3][1] += ResolvedView.PrevPreViewTranslation.y;
    PreviousLocalToWorldTranslated[3][2] += ResolvedView.PrevPreViewTranslation.z;
    return mul(float4(Intermediates.Position, 1), PreviousLocalToWorldTranslated);
}

float4 VertexFactoryGetRasterizedWorldPosition(
		FVertexFactoryInput Input,
		FVertexFactoryIntermediates Intermediates,
		float4 InWorldPosition)
{
		return InWorldPosition;
}

float3 VertexFactoryGetPositionForVertexLighting(
		FVertexFactoryInput Input,
		FVertexFactoryIntermediates Intermediates,
		float3 TranslatedWorldPosition)
{
		return TranslatedWorldPosition;
}


/** Get the 3x3 tangent basis vectors for this vertex factory. This vertex factory will calculate the binormal on-the-fly. */
half3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return Intermediates.TangentToLocal;
}

#if INSTANCED_STEREO
uint VertexFactoryGetEyeIndex(uint InstanceId)
{
	#if USE_INSTANCING
		return InstancedEyeIndex;
	#else
		return InstanceId & 1;
	#endif
}
#endif

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(
		FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
		FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS)0;
		Interpolants.TangentToWorld0 = float4(Intermediates.TangentToWorld[0], 0);
		Interpolants.TangentToWorld2 = float4(Intermediates.TangentToWorld[2], Intermediates.TangentToWorldSign);
		Interpolants.Color = Intermediates.Color;

#if INSTANCED_STEREO
		Interpolants.EyeIndex = 0;
#endif

		return Interpolants;
}

FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
    FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();

    Result.Particle.Color = half4(1, 1, 1, 1);
    Result.TwoSidedSign = 1;
		Result.VertexColor = Interpolants.Color;

    half3 TangentToWorld0 = Interpolants.TangentToWorld0.xyz;
    half4 TangentToWorld2 = Interpolants.TangentToWorld2;
    Result.UnMirrored = TangentToWorld2.w;
    Result.TangentToWorld = AssembleTangentToWorld(TangentToWorld0, TangentToWorld2);

    return Result;
}

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	float4 ObjectWorldPositionAndRadius = GetPrimitiveData(GetPrimitiveId(Interpolants)).ObjectWorldPositionAndRadius;
	return float4(ObjectWorldPositionAndRadius.xyz + ResolvedView.PreViewTranslation.xyz, ObjectWorldPositionAndRadius.w);
}

uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
		return 0;
}
