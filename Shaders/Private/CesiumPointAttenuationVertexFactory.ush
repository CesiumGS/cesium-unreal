// Copyright 2020-2021 CesiumGS, Inc. and Contributors

/*=============================================================================
	CesiumPointAttenuationVertexFactory.ush: point attenuation vertex factory shader code.
=============================================================================*/

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/VertexFactoryCommon.ush"

StructuredBuffer<float3> PositionBuffer;
Buffer<float4> PackedTangentsBuffer;
Buffer<float4> ColorBuffer;

// Whether or not the point cloud has per-point colors.
uint bHasPointColors;
float3 AttenuationParameters;
float4 ConstantColor;

#if USE_INSTANCING
	// Instanced stereo sets the eye index explicitly for instanced geometry
	#if INSTANCED_STEREO
	uint InstancedEyeIndex;
	#endif
#endif

/*
 * Per-vertex input. No vertex buffers are bound.
 */
struct FVertexFactoryInput
{
		uint  VertexId    : SV_VertexID;
		uint  InstanceId  : SV_InstanceID;
};

/** 
 * Per-vertex inputs. Used by passes with a trimmed down position-only shader.
 */
struct FPositionOnlyVertexFactoryInput
{
		uint	VertexId	: SV_VertexID;
};

/** 
 * Per-vertex inputs. Used by passes with a trimmed down position-and-normal-only shader.
 */
struct FPositionAndNormalOnlyVertexFactoryInput
{
		uint	VertexId	: SV_VertexID;
};

/** Cached intermediates that would otherwise have to be computed multiple times. */
struct FVertexFactoryIntermediates
{
		float3 Position;
		float3 AttenuatedWorldPosition;

  	half3x3 TangentToLocal;
		half3x3 TangentToWorld;
		half TangentToWorldSign;

		half4 Color;
		
		/** Cached primitive and instance data */
		FSceneDataIntermediates SceneData;
};

struct FVertexFactoryInterpolantsVSToPS
{
		TANGENTTOWORLD_INTERPOLATOR_BLOCK
		half4	Color : COLOR0;

#if INSTANCED_STEREO
		nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
#endif
};

float3 ApplyAttenuation(float4 WorldPosition, uint CornerIndex) {
		// Unreal uses counter-clockwise winding order.
		// 0 --- 3
		// |  \  |
		// 1 --- 2

		// Results in -0.5 for 0, 1 and 0.5 for 2, 3
		float OffsetX = CornerIndex / 2 - 0.5;
		float OffsetY = -0.5f;
		if (CornerIndex == 0 || CornerIndex == 3) {
				OffsetY = 0.5;
		}

		float4 PositionView = mul(WorldPosition, ResolvedView.TranslatedWorldToView);
		float4 PositionClip = mul(WorldPosition, ResolvedView.TranslatedWorldToClip);

		float MaximumPointSize = AttenuationParameters.x;
		float GeometricError = AttenuationParameters.y;
		float DepthMultiplier = AttenuationParameters.z;
		float Depth = PositionView.z / 100; // Get depth in meters
		float PointSize = 10;//min((GeometricError / Depth) * DepthMultiplier, MaximumPointSize);

		float2 PixelOffset = PointSize * float2(OffsetX, OffsetY);
		float2 ScreenOffset = PixelOffset * ResolvedView.ViewSizeAndInvSize.zw;
		float2 ClipOffset = ScreenOffset * PositionClip.w;
		float4 ViewOffset = mul(float4(ClipOffset, PositionClip.z, 1), ResolvedView.ClipToView);
		ViewOffset /= ViewOffset.w;

		// Adjust x-component for the left-handed coordinate system.
		return WorldPosition.xyz + (-ViewOffset.x * ResolvedView.ViewRight + ViewOffset.y * ResolvedView.ViewUp);
}

/** Helper function for position-only passes that don't require point index for other intermediates.*/
float3 GetAttenuatedWorldPosition(uint VertexId)
{
		uint PointIndex = VertexId / 4;
		uint CornerIndex = VertexId - (PointIndex * 4);

		float3 Position = PositionBuffer[PointIndex];
		float4 WorldPosition = TransformLocalToTranslatedWorld(Position);
		return ApplyAttenuation(WorldPosition, CornerIndex);
}

/** Computes TangentToLocal based on the Manual Vertex Fetch method in LocalVertexFactory.ush */
half3x3 CalcTangentToLocal(uint PointIndex, out float TangentSign)
{
		half3 TangentX = PackedTangentsBuffer[2 * PointIndex].xyz;
		half4 TangentZ = PackedTangentsBuffer[2 * PointIndex + 1].xyzw;

		TangentSign = TangentZ.w;

		// Derive the binormal by getting the cross product of the normal and tangent
		half3 TangentY = cross(TangentZ.xyz, TangentX) * TangentZ.w;
	
		// Recalculate TangentX off of the other two vectors
		// This corrects quantization errors since TangentX was passed in as a quantized vertex input
		half3x3 Result;
		Result[0] = cross(TangentY, TangentZ.xyz) * TangentZ.w;
		Result[1] = TangentY;
		Result[2] = TangentZ.xyz;

		return Result;
}

half3x3 CalcTangentToWorldNoScale(half3x3 TangentToLocal)
{
	half3x3 LocalToWorld = GetLocalToWorld3x3();
	half3 InvScale = Primitive.InvNonUniformScale;
	LocalToWorld[0] *= InvScale.x;
	LocalToWorld[1] *= InvScale.y;
	LocalToWorld[2] *= InvScale.z;
	return mul(TangentToLocal, LocalToWorld);
}

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
		FVertexFactoryIntermediates Intermediates = (FVertexFactoryIntermediates)0;
		Intermediates.SceneData = VF_GPUSCENE_GET_INTERMEDIATES(Input);
		
		uint PointIndex = Input.VertexId / 4;
		uint CornerIndex = Input.VertexId - (PointIndex * 4);

		Intermediates.Position = PositionBuffer[PointIndex];
		float4 WorldPosition = TransformLocalToTranslatedWorld(Intermediates.Position);
		Intermediates.AttenuatedWorldPosition = ApplyAttenuation(WorldPosition, CornerIndex);

		float TangentSign = 1.0;
		Intermediates.TangentToLocal = half3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);//CalcTangentToLocal(Input.VertexId, TangentSign);
		Intermediates.TangentToWorld = CalcTangentToWorldNoScale(Intermediates.TangentToLocal);
		Intermediates.TangentToWorldSign =  Intermediates.SceneData.InstanceData.DeterminantSign;

		bool bHasColors = bHasPointColors;
		float4 Color = bHasColors ? ColorBuffer[PointIndex] : ConstantColor;
		Intermediates.Color = Color FMANUALFETCH_COLOR_COMPONENT_SWIZZLE;

		return Intermediates;
}

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(
		FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
		FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS)0;
		Interpolants.TangentToWorld0 = float4(Intermediates.TangentToWorld[0], 0);
		Interpolants.TangentToWorld2 = float4(Intermediates.TangentToWorld[2], Intermediates.TangentToWorldSign);
		Interpolants.Color = Intermediates.Color;

#if INSTANCED_STEREO
		Interpolants.EyeIndex = 0;
#endif

		return Interpolants;
}

/** Get the 3x3 tangent basis vectors for this vertex factory. This vertex factory will calculate the binormal on-the-fly. */
half3x3 VertexFactoryGetTangentToLocal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return Intermediates.TangentToLocal;
}

float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
		return float4(Intermediates.AttenuatedWorldPosition, 1);
}

float4 VertexFactoryGetWorldPosition(FPositionOnlyVertexFactoryInput Input)
{
		return float4(GetAttenuatedWorldPosition(Input.VertexId), 1);
}

float4 VertexFactoryGetWorldPosition(FPositionAndNormalOnlyVertexFactoryInput Input)
{
		return float4(GetAttenuatedWorldPosition(Input.VertexId), 1);
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input)
{
		return float3(0, 0, 1);//RotateLocalToWorld(bUseStaticBuffers ? Input.Normal.xyz : GetInstanceData(Input.VertexId).TangentToLocal[2], 0);
}

float3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
		return float3(0, 0, 1);//return Intermediates.TangentToWorld[2];
}

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
    return mul(float4(Intermediates.Position, 1),
							 LWCMultiplyTranslation(Intermediates.SceneData.InstanceData.PrevLocalToWorld, ResolvedView.PrevPreViewTranslation));
}

float4 VertexFactoryGetRasterizedWorldPosition(
		FVertexFactoryInput Input,
		FVertexFactoryIntermediates Intermediates,
		float4 InWorldPosition)
{
		return InWorldPosition;
}

float3 VertexFactoryGetPositionForVertexLighting(
		FVertexFactoryInput Input,
		FVertexFactoryIntermediates Intermediates,
		float3 TranslatedWorldPosition)
{
		return TranslatedWorldPosition;
}

/** Converts from vertex factory specific input to a FMaterialVertexParameters, which is used by vertex shader material inputs. */
FMaterialVertexParameters GetMaterialVertexParameters(
		FVertexFactoryInput Input,
		FVertexFactoryIntermediates Intermediates,
		float3 WorldPosition,
		half3x3 TangentToLocal)
{
		FMaterialVertexParameters Result = (FMaterialVertexParameters)0;
    
		Result.SceneData = Intermediates.SceneData;
		Result.WorldPosition = WorldPosition;
		Result.TangentToWorld = Intermediates.TangentToWorld;
		Result.PreSkinnedNormal = TangentToLocal[2];
		Result.PreSkinnedPosition = WorldPosition;
		Result.VertexColor = Intermediates.Color;

    return Result;
}

FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
    FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();

    Result.Particle.Color = half4(1, 1, 1, 1);
    Result.TwoSidedSign = 1;
		Result.VertexColor = Interpolants.Color;

    half3 TangentToWorld0 = Interpolants.TangentToWorld0.xyz;
    half4 TangentToWorld2 = Interpolants.TangentToWorld2;
    Result.UnMirrored = TangentToWorld2.w;
    Result.TangentToWorld = AssembleTangentToWorld(TangentToWorld0, TangentToWorld2);

    return Result;
}

#if USE_INSTANCING
float4 VertexFactoryGetInstanceHitProxyId(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates) { return 0; }
#endif

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(FVertexFactoryInterpolantsVSToPS Interpolants)
{
		FPrimitiveSceneData PrimitiveData = GetPrimitiveDataFromUniformBuffer();
		return float4(LWCToFloat(LWCAdd(PrimitiveData.ObjectWorldPosition, ResolvedView.PreViewTranslation)), PrimitiveData.ObjectRadius);
}

#if INSTANCED_STEREO
uint VertexFactoryGetEyeIndex(uint InstanceId)
{
		#if USE_INSTANCING
			return InstancedEyeIndex;
		#else
			return InstanceId & 1;
		#endif
}
#endif

#if NEEDS_VERTEX_FACTORY_INTERPOLATION
struct FVertexFactoryRayTracingInterpolants
{
		FVertexFactoryInterpolantsVSToPS InterpolantsVSToPS;
};

float2 VertexFactoryGetRayTracingTextureCoordinate(FVertexFactoryRayTracingInterpolants Interpolants)
{
		return float2(0,0);
}

FVertexFactoryInterpolantsVSToPS VertexFactoryAssignInterpolants(FVertexFactoryRayTracingInterpolants Input)
{
		return Input.InterpolantsVSToPS;
}

FVertexFactoryRayTracingInterpolants VertexFactoryGetRayTracingInterpolants(
		FVertexFactoryInput Input,
		FVertexFactoryIntermediates Intermediates,
		FMaterialVertexParameters VertexParameters)
{
		FVertexFactoryRayTracingInterpolants Interpolants;
		Interpolants.InterpolantsVSToPS = VertexFactoryGetInterpolantsVSToPS(Input, Intermediates, VertexParameters);
		return Interpolants;
}

FVertexFactoryRayTracingInterpolants VertexFactoryInterpolate(
			FVertexFactoryRayTracingInterpolants a,
			float aInterp,
			FVertexFactoryRayTracingInterpolants b,
			float bInterp)
{
		FVertexFactoryRayTracingInterpolants O;
	
		INTERPOLATE_MEMBER(InterpolantsVSToPS.TangentToWorld0.xyz);
		INTERPOLATE_MEMBER(InterpolantsVSToPS.TangentToWorld2);

#if INTERPOLATE_VERTEX_COLOR
		INTERPOLATE_MEMBER(InterpolantsVSToPS.Color);
#endif

		return O;
}
#endif // #if NEEDS_VERTEX_FACTORY_INTERPOLATION

uint VertexFactoryGetPrimitiveId(FVertexFactoryInterpolantsVSToPS Interpolants)
{
		return 0;
}

#include "/Engine/Private/VertexFactoryDefaultInterface.ush"
