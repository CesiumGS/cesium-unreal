#pragma once

// Copyright 2020-2025 CesiumGS, Inc. and Contributors

/*=============================================================================
	CesiumShape.usf: An implicit shape that can be intersected by a ray.
=============================================================================*/

#include "CesiumBox.usf"
#include "CesiumCylinder.usf"
#include "CesiumEllipsoidRegion.usf"
#include "CesiumShapeConstants.usf"

struct Shape
{
  int ShapeConstant;
  Box BoxShape;
  Cylinder CylinderShape;
  EllipsoidRegion RegionShape;
  IntersectionListState ListState;
  
  /**
  * Interpret the input parameters according to the voxel grid shape.
  */
  void Initialize(in int InShapeConstant, float3 InMinBounds, float3 InMaxBounds, float4 PackedData0, float4 PackedData1, float4 PackedData2, float4 PackedData3, float4 PackedData4, float4 PackedData5)
  {
    ShapeConstant = InShapeConstant;

    [branch]
    switch (ShapeConstant)
    {
      case BOX:
        // Initialize with default unit box bounds.
        BoxShape.MinBounds = -1;
        BoxShape.MaxBounds = 1;
        break;
      case CYLINDER:
        CylinderShape.Initialize(InMinBounds, InMaxBounds, PackedData0, PackedData1, PackedData2);
        break;
      case ELLIPSOID:
        RegionShape.Initialize(InMinBounds, InMaxBounds, PackedData0, PackedData1, PackedData2, PackedData3, PackedData4, PackedData5);
        break;
    }
  }
    
  /**
  * Tests whether the input ray (Unit Space) intersects the shape.
  */
  RayIntersections Intersect(in Ray R, out float4 Intersections[INTERSECTIONS_LENGTH])
  { 
    [branch]
    switch (ShapeConstant)
    {
      case BOX:
        BoxShape.Intersect(R, Intersections, ListState);
        break;
      case CYLINDER:
        CylinderShape.Intersect(R, Intersections, ListState);
        break;
      case ELLIPSOID:
        RegionShape.Intersect(R, Intersections, ListState);
        break;
      default:
        return NewRayIntersections(NewMissedIntersection(), NewMissedIntersection());
    }

    RayIntersections result = ListState.GetFirstIntersections(Intersections);
    if (result.Entry.t == NO_HIT)
    {
      // Don't bother with sorting if the positive shape was missed.
      return result;
    }

    // Box intersection is straightforward and doesn't require sorting.
    if (ShapeConstant != BOX)
    {
      ListState.Sort(Intersections);
      for (int i = 0; i < SHAPE_INTERSECTIONS; ++i)
      {
        result = ListState.GetNextIntersections(Intersections);
        if (result.Exit.t > 0.0)
        {
          // Set start to 0.0 when ray is inside the shape.
          result.Entry.t = max(result.Entry.t, 0.0);
          break;
        }
      }
    }
    else
    {
      // Set start to 0.0 when ray is inside the shape.
      result.Entry.t = max(result.Entry.t, 0.0);
    }

    return result;
  }
  
  /**
  * Scales the input UV coordinates from [0, 1] to their values in UV Shape Space.  
  */
  float3 ScaleUVToShapeUVSpace(in float3 UV)
  {
    [branch]
    switch (ShapeConstant)
    {
      case CYLINDER:
        return CylinderShape.ScaleUVToShapeUVSpace(UV);
      case ELLIPSOID:
        return RegionShape.ScaleUVToShapeUVSpace(UV);
      case BOX:
      default:
        return UV;
    }
  }
  
  /**
  * Converts the input position (vanilla UV Space) to its Shape UV Space relative to the
  * voxel grid geometry. Also outputs the Jacobian transpose for future use.
  */
  float3 ConvertUVToShapeUVSpace(in float3 UVPosition, out float3x3 JacobianT)
  {
    [branch]
    switch (ShapeConstant)
    {
      case BOX:
        return BoxShape.ConvertUVToShapeUVSpace(UVPosition, JacobianT);
      case CYLINDER:
        return CylinderShape.ConvertUVToShapeUVSpace(UVPosition, JacobianT);
      case ELLIPSOID:
        return RegionShape.ConvertUVToShapeUVSpace(UVPosition, JacobianT);
      default:
        // Default return
        JacobianT = float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return UVPosition;
    }
  }
};
