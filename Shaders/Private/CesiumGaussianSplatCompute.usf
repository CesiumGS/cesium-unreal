void {FunctionName}(
  float4x4 M_SystemLocalToWorld, 
  float4x4 M_SystemWorldToLocal,
  int Index,
  float3 CameraPosition,
  out float4 OutPosition,
  out float4 OutColor,
  out float2 OutSpriteSize,
  out float OutSpriteRotation)
{
  // Obtain the tile-level values.
  int TileIndex = {TileIndicesBuffer}[Index];
  float4x4 TileMatrix = float4x4(
    {TileTransformsBuffer}[TileIndex * 9 + 0],
    {TileTransformsBuffer}[TileIndex * 9 + 1],
    {TileTransformsBuffer}[TileIndex * 9 + 2],
    {TileTransformsBuffer}[TileIndex * 9 + 3]
  );
  float4x4 InverseTileMatrix = float4x4(
    {TileTransformsBuffer}[TileIndex * 9 + 4],
    {TileTransformsBuffer}[TileIndex * 9 + 5],
    {TileTransformsBuffer}[TileIndex * 9 + 6],
    {TileTransformsBuffer}[TileIndex * 9 + 7]
  );
  float3 TileScale = {TileTransformsBuffer}[TileIndex * 9 + 8].xyz;
  float InVisibility = {TileTransformsBuffer}[TileIndex * 9 + 8].w;

  // Obtain all the splat values from the various buffers.
  float4 InPosition = mul(TileMatrix, float4({PositionsBuffer}[Index].xyz, 1.0));
  float4 InColor = {ColorsBuffer}[Index];
  // Scale we can combine directly with the tile-level scale.
  float3 InScale = TileScale * {ScalesBuffer}[Index].xyz;
  float4 InRotation = {RotationsBuffer}[Index];

  // Set default output values
  OutPosition = InPosition;
  OutColor = float4(0.0, 0.0, 0.0, 0.0);
  OutSpriteRotation = 0;
  OutSpriteSize = float2(0.0, 0.0);

  float4 WorldPos_H = mul(InPosition, M_SystemLocalToWorld);
  // Account for the world offset.
  WorldPos_H.xyz += LWCHackToFloat(PrimaryView.PreViewTranslation); 
  float4 ViewPos_H = mul(WorldPos_H, View.TranslatedWorldToView) * InVisibility;
  float4 ClipPos_H = mul(ViewPos_H, View.ViewToClip) * InVisibility;

  // Compute a position that moves the particle far out of camera view if discarded.
  float4 ViewPosFar = float4(LWCHackToFloat(PrimaryView.WorldViewOrigin) - LWCHackToFloat(PrimaryView.ViewForward) * 1000000.0f, 1.0f);
  float4 DiscardPos = mul(ViewPosFar, M_SystemWorldToLocal);

  // Provide a buffer of 20% around the screen edges so edge-adjacent splats aren't
  // prematurely discarded if they still affect the screen.
  float clip = 1.2 * ClipPos_H.w;
  if (
    ClipPos_H.z < -clip || ClipPos_H.x < -clip || ClipPos_H.x > clip ||
    ClipPos_H.y < -clip || ClipPos_H.y > clip )
  {
    OutPosition = DiscardPos;
    return;
  }

  // Normalize the clip coordinates.
  ClipPos_H = ClipPos_H / ClipPos_H.w;

  // Calculate the covariance matrix.
  // This is the three-dimensional equivalent to the variance of a normal distribution.

  float3x3 Vrk;
  {

    float3x3 S = float3x3(
      InScale.x, 0.0f, 0.0f,
      0.0f, InScale.y, 0.0f,
      0.0f, 0.0f, InScale.z
    );
    float3x3 R;
    {
      float x = InRotation.x;
      float y = InRotation.y;
      float z = InRotation.z;
      float w = InRotation.w;
      R = float3x3(
        1 - 2 * (y * y + z * z), 2 * (x * y - w * z),     2 * (x * z + w * y),
        2 * (x * y + w * z),     1 - 2 * (x * x + z * z), 2 * (y * z - w * x),
        2 * (x * z - w * y),     2 * (y * z + w * x),     1 - 2 * (x * x + y * y)
      );
    }

      float3x3 M = mul(S, R); 
      // Compute the 3D covariance matrix in world space.
      Vrk = mul(transpose(M), M);
  }

  // Now transform the world-space covariance matrix to clip-space.
  // We can't use the actual projection matrix as this would distort the gaussian.
  // Instead, we compute an affine approximation of the projection matrix called the Jacobian.
  // See the section of the below article starting with "The second step involves..." for more information:
  // https://shi-yan.github.io/how_to_render_a_single_gaussian_splat/
  float2 focal = float2(View.ViewToClip[0][0], View.ViewToClip[1][1]) * 0.5 * View.ViewSizeAndInvSize.xy;
  float4 t = ViewPos_H;
  float2 J1 = focal / t.z;
  float2 J2 = -focal * float2(t.x, t.y) / (t.z * t.z);
  float3x3 J = float3x3(
    J1.x, 0.0, J2.x,
    0.0, J1.y, J2.y,
    0.0, 0.0, 0.0
  );

  // Transform our covariance into view space, ensuring the rotation is correct
  float3x3 W = (float3x3) transpose(View.TranslatedWorldToView);
  float3x3 VrkView = mul(mul(W, Vrk), transpose(W));
  float3x3 cov = mul(mul(J, VrkView), transpose(J));

  // Calculate the eigenvectors of the gaussian splat.
  // These vectors define the bounds of the quad that will contain our gaussian.
  // For more information:
  // https://www.sctheblog.com/blog/gaussian-splatting/#method-2-calculate-eigenvectors
  float diagonal1 = cov[0][0] + 0.3;
  float diagonal2 = cov[1][1] + 0.3;
  float offDiagonal = cov[0][1];

  float mid = 0.5 * (diagonal1 + diagonal2);
  float radius = length(float2((diagonal1 - diagonal2) * 0.5, offDiagonal));
  float lambda1 = mid + radius;
  float lambda2 = max(mid - radius, 0.1);

  float2 diagonalVector = normalize(float2(offDiagonal, lambda1 - diagonal1));

  // Extract the major and minor axes of the Gaussian ellipsoid used to calculate
  // the vertex position in clip space.
  float2 majorAxis = min(3.0 * sqrt(lambda1), 1024.0) * diagonalVector;
  float2 minorAxis = min(3.0 * sqrt(lambda2), 1024.0) * float2(diagonalVector.y, -diagonalVector.x);

  // Clip splats that will be too small on the screen.
  if (dot(majorAxis, majorAxis) < 4.0 && dot(minorAxis, minorAxis) < 4.0) 
  {
    OutPosition = DiscardPos;
    return;
  }

  // Transform the perpendicular screen-space eigenvectors into a
  // world-space size and rotation for the Niagara sprite.
  float4 xClip = ClipPos_H + float4(majorAxis * View.ViewSizeAndInvSize.zw * 2.0, 0, 0);
  float4 yClip = ClipPos_H + float4(minorAxis * View.ViewSizeAndInvSize.zw * 2.0, 0, 0);

  float4 xWorld = mul(xClip, View.ClipToTranslatedWorld);
  float4 yWorld = mul(yClip, View.ClipToTranslatedWorld);
  xWorld /= xWorld.w;
  yWorld /= yWorld.w;

  // The size of the sprite is the length of the two world-space eigenvectors from the center.
  // Since they are perpendicular, they define a quad. 
  OutSpriteSize.x = length(WorldPos_H - xWorld) * 4.0;
  OutSpriteSize.y = length(WorldPos_H - yWorld) * 4.0;

  // Calculate the rotation of the quad to fit the eigenvectors.
  float Z = dot(float2(0,1), normalize(minorAxis));
  OutSpriteRotation = degrees(acos(Z));

  // Compute the spherical harmonics.
  // Spherical harmonics are basically an approximation of a function on the surface of a sphere.
  // With a set of coefficients, we can reconstruct that original function. The more coefficients
  // we add, the closer that approximation gets to the real thing. 
  // Here, the surface of the sphere represents all possible viewing directions,
  // and the result represents the change in color from different directions.
  {
    const float SH_C1   = 0.48860251;
    const float SH_C2[] = {
      1.092548430,
      -1.09254843,
      0.315391565,
      -1.09254843,
      0.546274215};
    const float SH_C3[] = {
      -0.59004358,
      2.890611442,
      -0.45704579,
      0.373176332,
      -0.45704579,
      1.445305721,
      -0.59004358
    };

    int SHCount = {SHDegrees}[TileIndex * 3];
    int coefficientOffset = {SHDegrees}[TileIndex * 3 + 1];
    int splatOffset = {SHDegrees}[TileIndex * 3 + 2];
    int SHOffset = coefficientOffset + (Index - splatOffset) * SHCount;

    float3 WorldViewDir = normalize(WorldPos_H - CameraPosition);
    float3x3 WorldToLocal = mul(InverseTileMatrix, M_SystemWorldToLocal);
    float3 LocalViewDir = normalize(mul(WorldViewDir, InverseTileMatrix));
    const float x = LocalViewDir.x;
    const float y = LocalViewDir.y;
    const float z = LocalViewDir.z;

    const float xx = x * x;
    const float yy = y * y;
    const float zz = z * z;
    const float xy = x * y;
    const float yz = y * z;
    const float xz = x * z;
    const float xyz = x * y * z;

    float3 SHColor = float3(0.0, 0.0, 0.0);
    if (SHCount >= 3) {
      float3 shd1_0 = {SHCoeffs}[SHOffset].xyz;
      float3 shd1_1 = {SHCoeffs}[SHOffset + 1].xyz;
      float3 shd1_2 = {SHCoeffs}[SHOffset + 2].xyz;
      SHColor += -SH_C1 * y * shd1_0 + SH_C1 * z * shd1_1 - SH_C1 * x * shd1_2;
    }

    if (SHCount >= 8) {
      float3 shd2_0 = {SHCoeffs}[SHOffset + 3].xyz;
      float3 shd2_1 = {SHCoeffs}[SHOffset + 4].xyz;
      float3 shd2_2 = {SHCoeffs}[SHOffset + 5].xyz;
      float3 shd2_3 = {SHCoeffs}[SHOffset + 6].xyz;
      float3 shd2_4 = {SHCoeffs}[SHOffset + 7].xyz;
      SHColor += SH_C2[0] * xy * shd2_0
              +  SH_C2[1] * yz * shd2_1
              +  SH_C2[2] * (2.0 * zz - xx - yy) * shd2_2
              +  SH_C2[3] * xz * shd2_3
              +  SH_C2[4] * (xx - yy) * shd2_4;
    }

    if (SHCount >= 15) {
      float3 shd3_0 = {SHCoeffs}[SHOffset + 8].xyz;
      float3 shd3_1 = {SHCoeffs}[SHOffset + 9].xyz;
      float3 shd3_2 = {SHCoeffs}[SHOffset + 10].xyz;
      float3 shd3_3 = {SHCoeffs}[SHOffset + 11].xyz;
      float3 shd3_4 = {SHCoeffs}[SHOffset + 12].xyz;
      float3 shd3_5 = {SHCoeffs}[SHOffset + 13].xyz;
      float3 shd3_6 = {SHCoeffs}[SHOffset + 14].xyz;

      SHColor += SH_C3[0] * y * (3.0 * xx - yy) * shd3_0
              +  SH_C3[1] * xyz * shd3_1
              +  SH_C3[2] * y * (4.0 * zz - xx - yy) * shd3_2
              +  SH_C3[3] * z * (2.0 * zz - 3.0 * xx - 3.0 * yy) * shd3_3
              +  SH_C3[4] * x * (4.0 * zz - xx - yy) * shd3_4
              +  SH_C3[5] * z * (xx - yy) * shd3_5
              +  SH_C3[6] * x * (xx - 3.0 * yy) * shd3_6;
    }

    OutColor = InColor + float4(SHColor, 0.0);
  }
}
