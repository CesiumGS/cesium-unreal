/*
	DO NOT EDIT THIS FILE! THIS FILE WAS GENERATED AUTOMATICALLY BY CONAN-UE4CLI VERSION 0.0.38.
	THIS BOILERPLATE CODE IS INTENDED FOR USE WITH UNREAL ENGINE VERSION 4.27.
*/
using System;
using System.IO;
using UnrealBuildTool;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

//For Tools.DotNETCommon.JsonObject and Tools.DotNETCommon.FileReference
using Tools.DotNETCommon;

public class CesiumNative : ModuleRules
{
	public string cesiumNativeVersion = ""; // Empty string means get the version from extern/cesium-native.

	enum PythonExecutable
  {
			Unknown,
			python,
			python3
  }

	private PythonExecutable _python = PythonExecutable.Unknown;

	//Returns the identifier string for the given target, which includes its platform, architecture (if specified), and debug CRT status
	private string TargetIdentifier(ReadOnlyTargetRules target)
	{
		//Append the target's architecture to its platform name if an architecture was specified
		string id = (target.Architecture != null && target.Architecture.Length > 0) ?
			String.Format("{0}-{1}", target.Platform.ToString(), target.Architecture) :
			target.Platform.ToString();

		//Append a debug suffix for Windows debug targets that actually use the debug CRT
		bool isDebug = (target.Configuration == UnrealTargetConfiguration.Debug || target.Configuration == UnrealTargetConfiguration.DebugGame);
		if (isDebug && target.bDebugBuildsActuallyUseDebugCRT) {
			id += "-Debug";
		}

		return id;
	}

	private string GetProfileName(ReadOnlyTargetRules target)
  {
		return "ue" + this.GetEngineVersion() + "-" + this.TargetIdentifier(Target);
  }

	//Determines if a target's platform is a Windows target platform
	private bool IsWindows(ReadOnlyTargetRules target) {
		return target.IsInPlatformGroup(UnrealPlatformGroup.Windows);
	}

	//Returns the version string for the Unreal Engine being used to build this module
	private string GetEngineVersion()
	{
		//Attempt to parse the version JSON file
		string versionFile = Path.Combine(EngineDirectory, "Build", "Build.version");
		JsonObject version = JsonObject.Read(new FileReference(versionFile));

		//Return a version string including the major and minor version numbers, without the patch level
		return String.Format("{0}.{1}", version.GetIntegerField("MajorVersion"), version.GetIntegerField("MinorVersion"));
	}

	//Processes the JSON data produced by Conan that describes our dependencies
	private void ProcessDependencies(string depsJson, ReadOnlyTargetRules target, string stagingDir)
	{
		//We need to ensure libraries end with ".lib" under Windows
		string libPrefix = this.IsWindows(target) ? "" : "lib";
		string libSuffix = this.IsWindows(target) ? ".lib" : ".a";

		//Attempt to parse the JSON file
		JsonObject deps = JsonObject.Read(new FileReference(depsJson));

		//Process the list of dependencies
		foreach (JsonObject dep in deps.GetObjectArrayField("dependencies"))
		{
			//Add the header and library paths for the dependency package
			PublicIncludePaths.AddRange(dep.GetStringArrayField("include_paths"));

			string[] libPaths = dep.GetStringArrayField("lib_paths");

			// In the common case that there's exactly one entry in lib_paths, construct
			// fully-qualified paths to additional libraries rather than adding the paths
			// to PublicSystemLibraryPaths and requiring UBT to search them for the libs.
			string libPath = "";
			if (libPaths.Length == 1)
			{
				libPath = libPaths[0];
			}
			else
			{
				PublicSystemLibraryPaths.AddRange(libPaths);
			}

			//Add the preprocessor definitions from the dependency package
			PublicDefinitions.AddRange(dep.GetStringArrayField("defines"));

			//Link against the libraries from the package
			string[] libs = dep.GetStringArrayField("libs");
			foreach (string lib in libs)
			{
				string libFull =
					(lib.StartsWith(libPrefix) ? "" : libPrefix) +
					lib +
					(lib.EndsWith(libSuffix) ? "" : libSuffix);
				if (libPath.Length > 0)
				{
					Console.WriteLine(Path.Combine(libPath, libFull));
					PublicAdditionalLibraries.Add(Path.Combine(libPath, libFull));
				}
				else
				{
					PublicSystemLibraries.Add(libFull);
				}
			}

			//Ensure any shared libraries are staged alongside the binaries for the plugin
			List<string> searchDirs = new List<string>();
			searchDirs.AddRange(dep.GetStringArrayField("bin_paths"));
			searchDirs.AddRange(dep.GetStringArrayField("lib_paths"));
			foreach (string dir in searchDirs)
			{
				List<string> binaries = new List<string>();
				binaries.AddRange(Directory.GetFiles(dir, "*.dll"));
				binaries.AddRange(Directory.GetFiles(dir, "*.dylib"));
				binaries.AddRange(Directory.GetFiles(dir, "*.so"));
				foreach (string binary in binaries) {
					RuntimeDependencies.Add(Path.Combine("$(BinaryOutputDir)", Path.GetFileName(binary)), binary, StagedFileType.NonUFS);
				}
			}

			//Copy any data files needed by the package into our staging directory
			string[] dataDirs = dep.GetStringArrayField("res_paths");
			foreach (string dir in dataDirs)
			{
				string[] files = Directory.GetFiles(dir, "*", SearchOption.AllDirectories);
				foreach(string file in files) {
					RuntimeDependencies.Add(Path.Combine(stagingDir, Path.GetFileName(file)), file, StagedFileType.NonUFS);
				}
			}
		}
	}

	//Determines if we have precomputed dependency data for the specified target and Engine version, and processes it if we do
	private bool ProcessPrecomputedData(ReadOnlyTargetRules target, string engineVersion, string stagingDir)
	{
		//Resolve the paths to the files and directories that will exist if we have precomputed data for the target
		string targetDir = Path.Combine(ModuleDirectory, "precomputed", engineVersion, this.TargetIdentifier(target));
		string flagsFile = Path.Combine(targetDir, "flags.json");
		string includeDir = Path.Combine(targetDir, "include");
		string libDir = Path.Combine(targetDir, "lib");
		string binDir = Path.Combine(targetDir, "bin");
		string dataDir = Path.Combine(targetDir, "data");

		//If any of the required files or directories do not exist then we do not have precomputed data
		if (!File.Exists(flagsFile) || !Directory.Exists(includeDir) || !Directory.Exists(libDir) || !Directory.Exists(binDir) || !Directory.Exists(dataDir)) {
			return false;
		}

		//Add the precomputed include directory to our search paths
		PublicIncludePaths.Add(includeDir);

		//Link against all static library files (and import libraries for DLLs under Windows) in the lib directory
		string libExtension = ((this.IsWindows(target)) ? ".lib" : ".a");
		string[] libs = Directory.GetFiles(libDir, "*" + libExtension);
		foreach(string lib in libs) {
			PublicAdditionalLibraries.Add(lib);
		}

		//Under non-Windows platforms, link against all shared library files in the lib directory
		if (this.IsWindows(target) == false)
		{
			List<string> sharedLibs = new List<string>();
			sharedLibs.AddRange(Directory.GetFiles(libDir, "*.dylib"));
			sharedLibs.AddRange(Directory.GetFiles(libDir, "*.so"));
			foreach(string lib in sharedLibs) {
				PublicAdditionalLibraries.Add(lib);
			}
		}

		//Ensure any shared libraries are staged alongside the binaries for the plugin
		string[] searchDirs = new string[]{ binDir, libDir };
		foreach (string dir in searchDirs)
		{
			List<string> binaries = new List<string>();
			binaries.AddRange(Directory.GetFiles(dir, "*.dll"));
			binaries.AddRange(Directory.GetFiles(dir, "*.dylib"));
			binaries.AddRange(Directory.GetFiles(dir, "*.so"));
			foreach (string binary in binaries) {
				RuntimeDependencies.Add(Path.Combine("$(BinaryOutputDir)", Path.GetFileName(binary)), binary, StagedFileType.NonUFS);
			}
		}

		//Attempt to parse the JSON file containing any additional flags, modules and system libraries
		JsonObject flags = JsonObject.Read(new FileReference(flagsFile));

		//Link against any Unreal Engine modules for bundled third-party libraries
		PrivateDependencyModuleNames.AddRange(flags.GetStringArrayField("unreal_modules"));

		//Add any preprocessor definitions specified by the JSON file
		PublicDefinitions.AddRange(flags.GetStringArrayField("defines"));

		//Link against any system libraries specified by the JSON file, ensuring we add the file extension if it is missing under Windows
		string[] systemLibs = flags.GetStringArrayField("system_libs");
		foreach (string lib in systemLibs)
		{
			string libFull = lib;
			if (this.IsWindows(target) && !libFull.EndsWith(libExtension)) {
				libFull += libExtension;
			}

			PublicSystemLibraries.Add(libFull);
		}

		//Copy any data files needed by the package into our staging directory
		string[] files = Directory.GetFiles(dataDir, "*", SearchOption.AllDirectories);
		foreach(string file in files) {
			RuntimeDependencies.Add(Path.Combine(stagingDir, Path.GetFileName(file)), file, StagedFileType.NonUFS);
		}

		return true;
	}

	public CesiumNative(ReadOnlyTargetRules Target) : base(Target)
	{
    //while (!Debugger.IsAttached)
    //{
    //  Thread.Sleep(100);
    //}

    Type = ModuleType.External;

		//Ensure our staging directory exists prior to copying any dependency data files into it
		string stagingDir = Path.Combine("$(ProjectDir)", "Binaries", "Data", "CesiumNative");
		if (!Directory.Exists(stagingDir)) {
			Directory.CreateDirectory(stagingDir);
		}

		bool preferDebug = (Target.Configuration == UnrealTargetConfiguration.Debug || Target.Configuration == UnrealTargetConfiguration.DebugGame);
		string config = preferDebug ? "Debug" : "Release";

		string automate = Path.Combine(ModuleDirectory, "../../extern/cesium-native/tools/automate.py");

		// If the appropriate environment variable is set, do a baked build of cesium-native, instead of
		// a regular development build. Baking copies cesium-native binaries and headers into
		// Cesium for Unreal so that future builds don't need to build cesium-native at all.
		// This is used for packaging the plugin for distribution, including in our continuous
		// integration process.
		string bakeCesiumNative = Environment.GetEnvironmentVariable("BAKE_CESIUM_NATIVE");
		if (bakeCesiumNative != null)
    {
			// Set up cesium-native for Conan package creation
			this.runPython(automate, "conan-export-recipes");
			this.runPython(automate, "generate-library-recipes");
			this.runPython(automate, "editable", "off");
			this.runPython(automate, "conan-export-libraries");

			// Run a conan install, which will also build cesium-native and its dependencies.
			this.runConanInstall(Target, config);

			// Run the conan-ue4cli bake to copy the binaries and headers to the location that
			// ProcessPrecomputedData below expects to find them.
			this.run("ue4", "conan", "bake", this.GetProfileName(Target));
		}

		//Determine if we have precomputed dependency data for the target that is being built
		if (this.ProcessPrecomputedData(Target, this.GetEngineVersion(), stagingDir) == false)
		{
			//No precomputed data detected, install third-party dependencies using Conan
			if (this.cesiumNativeVersion.Length == 0)
			{
				// Using the cesium-native submodule, so put it in editable mode.
				this.runPython(automate, "conan-export-recipes");
				this.runPython(automate, "generate-library-recipes", "--editable");
				this.runPython(automate, "editable", "on");
			}

			this.runConanInstall(Target, config);

			// When cesium-native is in editable mode, the above unfortunately won't actually compile it,
			// and then ProcessDependencies below will fail because of missing binaries.
			// So when we're in editable mode, run the cesium-native build here.
			string nativeDirectory = Path.Combine(ModuleDirectory, "..", "..", "extern", "cesium-native");
			string buildDirectory = Path.Combine(nativeDirectory, "build");
			string toolchainFile = Path.Combine(buildDirectory, "CesiumUtility", "conan", "conan_toolchain.cmake");

			this.run(
				"cmake",
				"-S", nativeDirectory,
				"-B", buildDirectory,
				"-DCMAKE_TOOLCHAIN_FILE=" + toolchainFile
 			);

			this.run(
				"cmake",
				"--build", buildDirectory,
				"--config", config
			);

			//Link against our Conan-installed dependencies
			this.ProcessDependencies(Path.Combine(ModuleDirectory, "conanbuildinfo.json"), Target, stagingDir);
		}
	}

	private string getClangMajorVersion(string clangPath)
  {
		using (Process p = Process.Start(new ProcessStartInfo
		{
			FileName = clangPath,
			Arguments = "-dumpversion",
			UseShellExecute = false,
			WorkingDirectory = ModuleDirectory,
			RedirectStandardOutput = true
		}))
    {
			p.WaitForExit();

			if (p.ExitCode == 0)
      {
				string version = p.StandardOutput.ReadLine();
				string[] parts = version.Split('.');
				return parts[0];
      }
			else
      {
				Console.Error.WriteLine("Clang version could not be determined. Clang probably isn't working.");
				return "10";
      }
    }
  }

	private string CreateConanProfile(ReadOnlyTargetRules Target, string config)
	{
		var settings = new Dictionary<string, string>();
		var env = new Dictionary<string, string>();
		var conf = new Dictionary<string, string>();

		settings.Add("build_type", config);
		env.Add("UNREAL_ENGINE_VERSION", this.GetEngineVersion());
		env.Add("UNREAL_ENGINE_DIR", EngineDirectory);
		env.Add("CESIUM_NATIVE_VERSION", this.cesiumNativeVersion);

		if (Target.IsInPlatformGroup(UnrealPlatformGroup.Windows) && Target.WindowsPlatform != null)
		{
			settings.Add("os", "Windows");
			settings.Add("compiler", "Visual Studio");

			var platform = Target.WindowsPlatform;
      if (platform.Compiler == WindowsCompiler.VisualStudio2017)
				settings.Add("compiler.version", "15");
      else if (platform.Compiler == WindowsCompiler.VisualStudio2019)
				settings.Add("compiler.version", "16");
      else
        Console.Error.WriteLine("Unsupported compiler: " + platform.Compiler.ToString());

			// Use the Release version of the C runtime library, even in debug builds.
			settings.Add("compiler.runtime", "MD");

			var architectureMap = new Dictionary<WindowsArchitecture, string>()
			{
				{ WindowsArchitecture.x86, "x86" },
				{ WindowsArchitecture.x64, "x86_64" },
				{ WindowsArchitecture.ARM32, "armv7" },
				{ WindowsArchitecture.ARM64, "armv8" },
			};

			settings.Add("arch", architectureMap[platform.Architecture]);
		}
		else if (Target.IsInPlatformGroup(UnrealPlatformGroup.Linux) && Target.LinuxPlatform != null)
    {
			// On Linux, we might be using the system compiler (i.e. default profile), or else
			// LINUX_MULTIARCH_ROOT must be set to the root of the linux toolchain.
			// See UnrealBuildTool's LinuxToolChain.cs, which controls how UE source code outside
			// Cesium Native is built. That is what this logic is attempting to mirror.
			string toolchainRoot = Environment.GetEnvironmentVariable("LINUX_MULTIARCH_ROOT");
			if (toolchainRoot == null) return "default";

			settings.Add("os", "Linux");
			settings.Add("compiler", "clang");
			settings.Add("compiler.libcxx", "libc++");

			var architectureMap = new Dictionary<string, string>()
			{
				{ "x86_64", "x86_64" },
				{ "aarch64", "armv8" }
			};

			string architecture = Target.Architecture.Split('-')[0];
			settings.Add("arch", architectureMap[architecture]);

			string baseLinuxPath = Path.Combine(toolchainRoot, Target.Architecture);
			string clangPath = Path.Combine(baseLinuxPath, "bin", "clang");
			string clangPPPath = Path.Combine(baseLinuxPath, "bin", "clang++");

			if (BuildHostPlatform.Current.Platform == UnrealTargetPlatform.Win64 || BuildHostPlatform.Current.Platform == UnrealTargetPlatform.Win32)
      {
				clangPath += ".exe";
				clangPPPath += ".exe";
      }

			settings.Add("compiler.version", this.getClangMajorVersion(clangPath));
			env.Add("CC", clangPath);
			env.Add("CXX", clangPPPath);
			env.Add("CONAN_CMAKE_SYSROOT", baseLinuxPath);
			env.Add("CMAKE_SYSROOT", baseLinuxPath);
			env.Add("CHOST", Target.Architecture);
			env.Add("CONAN_CMAKE_GENERATOR", "Ninja");
			env.Add("CMAKE_GENERATOR", "Ninja");

			string libcxxPath = Path.Combine(EngineDirectory, "Source", "ThirdParty", "Linux", "LibCxx");
			string[] includePaths = new string[]
			{
				//Path.Combine(libcxxPath, "include"),
				//Path.Combine(libcxxPath, "include/c++/v1")
			};
			var arguments = includePaths.Select(p => "\"-I" + p + "\"");

			env.Add("CXXFLAGS", "-nostdinc++ -target x86_64-unknown-linux-gnu " + string.Join(" ", arguments));
			env.Add("CFLAGS", "-target x86_64-unknown-linux-gnu");
			env.Add("CONAN_CMAKE_FIND_ROOT_PATH_MODE_PROGRAM", "NEVER");
			env.Add("CONAN_CMAKE_FIND_ROOT_PATH_MODE_LIBRARY", "ONLY");
			env.Add("CONAN_CMAKE_FIND_ROOT_PATH_MODE_INCLUDE", "ONLY");

			string toolchainFile = "C:/Dev/cfus-conan/Plugins/cesium-unreal/extern/unreal-linux-from-windows-toolchain.cmake"; // TODO
			env.Add("CONAN_CMAKE_TOOLCHAIN_FILE", toolchainFile);
			env.Add("UNREAL_ENGINE_COMPILER_DIR", baseLinuxPath);

			conf.Add("tools.cmake.cmaketoolchain:generator", "Ninja");
			conf.Add("tools.cmake.cmaketoolchain:user_toolchain", toolchainFile);
		}

		StringBuilder profile = new StringBuilder();
		profile.AppendLine("[settings]");
		foreach (var kvp in settings)
    {
			profile.AppendLine(kvp.Key + "=" + kvp.Value);
    }

		profile.AppendLine();

		profile.AppendLine("[env]");
		foreach (var kvp in env)
		{
			profile.AppendLine(kvp.Key + "=" + kvp.Value);
		}

		profile.AppendLine();

		profile.AppendLine("[conf]");
		foreach (var kvp in conf)
		{
			profile.AppendLine(kvp.Key + "=" + kvp.Value);
		}

		string path = Path.Combine(ModuleDirectory, "host.profile");

		Console.WriteLine("Generated Conan host profile:");
		Console.WriteLine(profile.ToString());
		Console.WriteLine();

		File.WriteAllText(path, profile.ToString(), Encoding.UTF8);

		return path;
	}

	private void runConanInstall(ReadOnlyTargetRules Target, string config)
  {
		List<string> args = new List<string>()
			{
				"install",
				".",
				"--build=outdated",
				"--build=cascade",
				"-g=json",
				"-pr:b=default",
				"-pr:h=" + this.CreateConanProfile(Target, config)
			};

		// On Windows, Unreal uses the Release C runtime library even in debug builds.
		if (config == "Debug" && Target.IsInPlatformGroup(UnrealPlatformGroup.Windows))
		{
			args.Add("-s compiler.runtime=MD");
		}

		this.run(
			"conan",
			args.ToArray()
		);
	}

	private void run(string command, params string[] args)
  {
		using (Process p = Process.Start(new ProcessStartInfo
		{
			FileName = command,
			Arguments = string.Join(" ", args),
			UseShellExecute = false,
			WorkingDirectory = ModuleDirectory
		}))
    {
			p.WaitForExit();

			if (p.ExitCode != 0)
			{
				throw new Exception("Command failed");
			}
		}
	}

	private void runPython(string script, params string[] args)
  {
		if (this._python == PythonExecutable.Unknown)
		{
			// Determine if we should use "python" or "python3" by invoking
			// python3 --version and seeing if it works. If not, assume we need
			// to use python.
			try
			{
				using (Process p = Process.Start(new ProcessStartInfo
				{
					FileName = "python3",
					Arguments = "--version",
					UseShellExecute = false,
					RedirectStandardOutput = true,
					RedirectStandardError = true
				}))
				{
					p.WaitForExit();

					if (p.ExitCode == 0)
					{
						this._python = PythonExecutable.python3;
					}
					else
					{
						this._python = PythonExecutable.python;
					}
				}
			}
			catch
			{
				this._python = PythonExecutable.python;
      }
		}

		string pythonCommand = this._python == PythonExecutable.python3 ? "python3" : "python";

		List<string> fullArgs = new List<string>() { script };
		fullArgs.AddRange(args);

		this.run(pythonCommand, fullArgs.ToArray());
	}
}
